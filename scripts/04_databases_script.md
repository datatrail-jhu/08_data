In lessons up to the point in the Course Set, the analyses you've done have either been carried out with a single dataset or the data have been compiled into a single data frame. However, there will be many cases as a data scientist where the data for your project will stored across a number of different spreadsheets that are all related to one another. In this lesson, we'll discuss what relational data are, why you would want to store data in this way, and how to work with these types of data in RStudio Cloud.

Relational data can be thought of as information being stored across many tables, with each table being related to all the other tables. Each table is linked to every other table by a set of unique identifiers. 

To better understand this, let's consider a toy example. We mentioned this example in the introductory lesson in this course, and we'll return to it now. Consider a town where you have a number of different restaurants. In one table you have information about these restaurants including, where they are located and what type of food they serve. You then have a second table where information about health and safety inspections is stored. Each inspection is a different row and the date of the inspection, the inspector, and the safety rating are stored in this table. Finally, you have a third table. This third table contains information pulled from an API, regarding the number of stars given to each restaurant, as rated by people online. Each table contains different bits of information; however, there is a common column id in each of the tables. This allows the information to be linked between the tables. The restaurant with the id "JJ29JJ" in the restaurant table would refer to the same restaurant with the id "JJ29JJ" in the health inspections table, and so on. The values in this id column are known as unique identifiers because they uniquely identify each restaurant. No two restaurants will have the same id, and the same restaurant will always have the same id, no matter what table you're looking at. The fact that these tables have unique identifiers connecting each table to all the other tables makes this example relational data.

Storing data in this way has a number of advantages; however, the three most important are that relational data allow Efficient Data Storage, Avoid Ambiguity, and increase data Privacy. With regards to efficient data storage, By storing each bit of information in a separate table, you limit the need to repeat information. Taking our example above, imagine if we included everything in a single table. This means that for each inspection, we would copy and paste the restaurant's address, type, and number of stars every time the facility is inspected. If a restaurant were inspected 15 times, this same information would be unnecessarily copy and pasted in each row! To avoid this, we simply separate out the information into different tables and relate them by their unique identifiers.

As for avoiding ambiguity, Take a look at the first table: "restaurant" here. You may notice there are two different restaurants named "Taco Stand." However, looking more closely, they have a different id and a different address. They're even different types of restaurants. So, despite having the same name, they actually are two different restaurants. The unique identifier makes this immediately clear! Finally, In using relational data, if there is ever information that is private and only some people should have access to, using this system simplifies that. You can restrict access to some of the data to ensure only those who should have access are able to access the data.

Now that we have an idea of what relational data are, let's spend a second talking about how relational data are stored. Relational data are stored in databases. The most common database is sequel lite. In order to work with data in databases, there has to be a way to query or search the database for the information you're interested in. sequel queries search through sequel lite databases and return the information you ask for in your query.For example, a query of the above example may look to obtain information about any restaurant that was inspected after July 1st of 2018. One would then use sequel commands to carry out this query and return the information requested.While we won't be discussing how to write sequel commands in-depth here, we will be discussing how to use the R package R S Q Lite to connect to an sequel lite database using R S Q Lite and how to work with relational data using d ply r and d b ply r. To better understand databases and how to work with relational data, let's just start working with data from a database! The data we'll be using are from a database frequently used to practice working with relational data: chinook dot db. The database includes 11 tables with data that represents a digital media store. The data includes information generally related to related to media, artists, artists' work, and those who purchase artists' work (customers). For our purposes, we're only going to only describe two of the tables we'll be using in our example in this lesson. We're going to be looking at data in the artists and albums tables. artists and albums are related by the column Artist I D.

Without any more details, let's get to it! Here you'll see the code to install and load the R S Q Lite package. You'll then download the chinook sample database, connect to the database, and first obtain a list the tables in the database:

The output from the d b list tables function will include 13 tables. Among them will be the two tables we're going to work through in our example: artists, and albums. In this example, we're downloading a database and working with the data locally. However, more often, when working with sequel lite databases, you'll be connecting remotely. Using the R S Q Lite package is particularly helpful in this case because it allows you to connect to and query the database from R without reading all the data in. This is helpful in the case of very large databases, where you'll want to avoid copying all the data and will instead want to only work with the parts of the database you need. 

To access these tables within RStudio Cloud, we'll have to install the packages d b ply r, which enables us to access the parts of the database we're going to be working with. d b ply r allows you to use the same functions you learned when working with d ply r; however, it allows you to use these functions with a database. While d b ply r has to be loaded to work with databases, you likely won't notice that you're using it beyond that. Otherwise, you'll just work with the files as if you were working with d ply r functions! After installing and loading d b ply r, we'll be able to use the helpful t b l function to extract the two tables we're interested in working with!

Mutating joins allow you to take two different tables and combine the variables from both tables. This requires that each table have a column relating the tables to one another. This unique identifier is used to match observations between the tables. However, when combining tables, there are a number of different ways in which the tables can be joined. We touched on this in the Data Tidying course; however, there we only covered left joins. Now, in this lesson, we'll cover inner joins, left joins, right joins, and full joins. Let's break down exactly what we mean by this using just a small toy example from the artists and albums tables from the chinook database. Here you see three rows from the artists table and four rows from the albums table

When talking about inner joins, we are only going to keep an observation if it is found in all of the tables we're combining. Here, we're combining the tables based on the Artist I D column. In our dummy example, there are only two artists that are found in both tables. Thus, only these artists' data will be included after the inner join.

In our toy example, when doing an inner join, data from any observation found in all the tables being joined are included in the output. Here, Artist I Ds "1" and "2" are in both the artists and albums tables. Thus, those will be the only Artist I Ds in the output from the inner join. And, since it's a mutating join, our new table will have information from both tables! We now have Artist I D, Name, Album I D, and Title in a single table! We've joined the two tables, based on the column Artist I D!

Now, to run this for our tables from the database, rather than just for a few rows in our toy example, you would do the following:

For a left join, all rows in the first table specified will be included in the output. Any row in the second table that is not in the first table will not be included. 

In our toy example this means that Artist IDs 1, 2, and 3 will be included in the output; however, Artist I D 4 will not. Thus, our output will again include all the columns from both tables combined into a single table; however, for Artist I D 3, there will be N As for Album I D and Title. N As will be filled in for any observations in the first table specified that are missing in the second table.

Now, to run this for our tables from the database, rather than just for a few rows in our toy example, you would as you see here.

Right Join is similar to what we just discussed; however, in the output from a right join, all rows in the final table specified are included in the output. N As will be included for any observations found in the last specified table but not in the other tables. In our toy example, that means, information about Artist I Ds 1, 2, and 4 will be included. d

Again, in our toy example, we see that right join combines the information across tables; however, in this case, Artist I D 4 is included, but Name is an NA, as this information was not in the artists table for this artist.

Now, to run this for our tables from the database, you would have to do something slightly different than what you saw above. Note in the code below that we have to change teh class of the tables from the database into tibbles before doing the join. This is because sequel does not currently support right or full joins, but d ply r does. Thus, we first have to be sure the data are a class that d ply r can work with using as underscore tibble. Other than that, the code below is similar to what you've seen already: While the output may look similar to the output from left underscore join, you'll note that there are a different number of rows due to how the join was done. The fact that 347 rows are present with the right join and 418 were present after the left join suggests that there are artists in the artists table without albums in the albums table.

Finally, a full join will take every observation from every table and include it in the output.

Thus, in our toy example, this join produces five rows, including all the observations from either table. N As are filled in when data are missing for an observation.

As you saw in the last example, to carry out a full join, we have to again specify that the objects are tibbles before being able to carry out the join

Now that we've walked through a number of examples of mutating joins, cases where you're combining information across tables, we just want to take a second to summarize the four types of joins discussed using a visual frequently used to explain the most common mutating joins where each circle represents a different table and the gray shading on the venn diagrams indicates which observations will be included after the join.

While we discussed mutating joins in detail, we're just going to mention the ability to carry out filtering joins. While mutating joins combined variables across tables, filtering joins affect the observations, not the variables. This still requires a unique identifier to match the observations between tables. Filtering joins keep observations in one table based on the observations present in a second table. Specifically a semi join keeps all observations in x with a match in y. An anti join keeps observations in x that do NOT have a match in y. In our toy example, if the join  semi join with artists and albums were run, this would keep rows of artists where the Artist I D in artist was also in the albums table.

Alternatively, anti join with artists and albums would output the rows of artists whose Artist I D was NOT found in the albums table. Note that in the case of filtering joins, the number of variables in the table after the join does not change. While mutating joins merged the tables creating a resulting table with more columns, with filtering joins we're simply filtering the observations in one table based on the values in a second table.

As mentioned briefly above, most often when working with databases, you won't be downloading the entire database. Instead, you'll connect to a server somewhere else where the data live and query the data, allowing you to search for the parts you need, from R. For example, in this lesson we downloaded the entire chinook database, but only ended up using artists and albums. In the future, instead of downloading all the data, you'll just connect to the database and work with the parts you need. This will require connecting to the database with host, user, and password. This information will be provided by the database's owners, but the syntax for entering this information into R to connect to the database would look something like what you see here: While not being discussed in detail here, it's important to know that connecting to remote databases from R is possible and that this allows you to query the database without reading all the data from the database into R. 

In this lesson we discussed what relational data are and how to work with them in R. This led to a discussion about the package R S Q Lite, which allows you to connect to and make queries from databases. With relational data in hand, we discussed both mutating joins and filtering joins. Finally, we touched very briefly on how to connect to a remote database from R. 